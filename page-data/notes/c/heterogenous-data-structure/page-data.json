{"componentChunkName":"component---src-templates-notes-template-js","path":"/notes/c/heterogenous-data-structure/","result":{"data":{"markdownRemark":{"html":"<h3>Structures</h3>\n<p><code>struct</code> creates a data type that groups objects of possibly different types into a single object.</p>\n<p>Unlike C++ or Java, C provides no support for objects and classes.</p>\n<p>For example if we have the following structure declaration, then it contains 3 fields of 4-byte <code>int</code>s and one 4-byte <code>int</code> pointer. Therefore it contains a total of 16 bytes.</p>\n<pre><code>struct square{\n    int i;\n    int j;\n    int len;\n    int *p;\n}\n</code></pre>\n<p>The address for the fields are:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Address</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>i</code></td>\n<td>x</td>\n</tr>\n<tr>\n<td><code>j</code></td>\n<td>x+4</td>\n</tr>\n<tr>\n<td><code>len</code></td>\n<td>x+8</td>\n</tr>\n<tr>\n<td><code>p</code></td>\n<td>x+12</td>\n</tr>\n</tbody>\n</table>\n<p>The compiler will allocate the appropriate addresses for the structures.</p>\n<h3>Unions</h3>\n<p>Example</p>\n<pre><code>struct s{\n    char c;\n    int i[2];\n    double v;\n}\n\nunion u{\n    char c;\n    int i[2];\n    double v;\n}\n</code></pre>\n<p>At compilation time the memory offsets will be</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th><code>s</code> Offsets</th>\n<th><code>u</code> Offsets</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>c</code></td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>i[2]</code></td>\n<td>4</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>v</code></td>\n<td>12</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>The <code>struct s</code> requires a total of 20 bytes whereas <code>union u</code> requires 8 bytes (the maximum size of the fields). Unions are useful for optimizing memory.</p>\n<p>Tree Example: A tree node is either an internal node or a leaf (two different fields in a data structure will be mutually exclusive)</p>\n<pre><code>struct node_s {\n    struct node_s *left;\n    struct node_s *right;\n    double data;\n};\n\nunion node_u {\n    struct {\n        union node_u *left;\n        union node_u *right;\n    } internal;\n    double data;\n};\n</code></pre>\n<p>With a structure every node requires 16 bytes whereas with an union it only requires 8 bytes. Right now we don't know which node is an internal node or a leaf so to make things better do the following instead.</p>\n<pre><code>typedef enum { n_leaf, n_internal } nodetype_t;\n\nstruct node {\n    nodetype_t type;\n    union {\n        struct {\n            struct node *left;\n            struct node *right;\n        } internal;\n        double data;\n    } info;\n};\n</code></pre>\n<h3>Data Alignment</h3>\n<p>Linux follows a 2-byte alignment for 2-byte data types and a 4-byte alignment for any larger data types. In Windows, any primitive object of K bytes, for K = 2, 4, or 8, must have an address that is a multiple of K. The alignment restrictions simplify the design of the hardware forming the interface between the processor and the memory system</p>","frontmatter":{"date":"May 17, 2024","slug":"heterogenous-data-structure","title":"Heterogenous Data Structure"}}},"pageContext":{"id":"d4ae3805-3900-5bac-893c-d0ab48df2636"}},"staticQueryHashes":[],"slicesMap":{}}