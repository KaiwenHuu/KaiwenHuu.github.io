{"componentChunkName":"component---src-templates-notes-template-js","path":"/notes/c/pointers/","result":{"data":{"markdownRemark":{"html":"<h3>Key Principles of Pointers in C</h3>\n<p>Example:</p>\n<pre><code>int a = 10;\nchar c = 'a';\nchar *cp = &#x26;c;\n\nint *ip;\nchar **cpp;\n\n# creating pointers\nip = &#x26;a;\ncpp = &#x26;cp;\n\nvoid *p;\np = &#x26;a;\np = &#x26;c;\n\n*ip = 100; # dereferencing\n</code></pre>\n<h4>Every pointer has an associated type</h4>\n<p><code>ip</code> is a pointer to an <code>int</code> and <code>cpp</code> is pointer to an object that itself is a pointer to a <code>char</code>.</p>\n<h4>Every pointer has a value</h4>\n<p>The pointer holds the value of an address of some object. If pointer equals <code>NULL</code> or <code>0</code>, then the pointer is not pointing to anything. Each pointer is created using the <code>&#x26;</code> operator, which can be used on any <em>lvalue</em> (anything to the left of the <code>=</code> sign). Pointers can also be dereferenced using the <code>*</code> operator.</p>\n<h4>Array and Pointer and Casting</h4>\n<p>Array referencing (e.g., <code>a[3]</code>) has the exact same effect as pointer dereferencing (e.g., <code>*(a+3)</code>). Both array referencing and pointer arithmetic require scaling the offsets by the object size.</p>\n<p><code>(int *) p+7</code> offsets the address by 28 bytes (because <code>int</code> has 4 bytes), but <code>(int *) (p+7)</code> will offset the address by 7 bytes. Note that <code>(char *) p+1</code> is just offsetting the address by 1 byte. In general if <code>p</code> is a pointer, then <code>p+i</code> (no casting) means the resulting address is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>+</mo><mi>L</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">p+Li</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">i</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span> is the size of the data type associated with the pointer.</p>\n<h4>Function Pointers</h4>\n<p>Example:</p>\n<pre><code>int foo(int x, int *p);\n</code></pre>\n<p>Assign a function pointer</p>\n<pre><code>(int) (*fp)(int, int *);\nfp = foo;\n</code></pre>\n<p>Invoke the function using the pointer</p>\n<pre><code>int x = 1;\nint result = fp(3, &#x26;x);\n</code></pre>\n<p>Note that <code>int *fp(int, int *)</code> would be read as <code>(int *) fp(int, int *);</code>, which means that theres a function <code>fp</code> that takes an <code>int</code> and <code>int *</code> as its arguments and returns an <code>int *</code>. <code>(int) (*fp)(int, int *)</code> means that <code>fp</code> is a pointer to a function that takes an <code>int</code> and <code>int *</code> as its arguments and returns an <code>int</code>.</p>","frontmatter":{"date":"May 11, 2024","slug":"pointers","title":"Pointers"}}},"pageContext":{"id":"03720ae2-baf2-5056-b2cd-6b00c464e2ca"}},"staticQueryHashes":[],"slicesMap":{}}